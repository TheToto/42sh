.TH 42SH 1
.SH NAME
42sh \- the ultimate answering SHell
.SH COMPILING
Make sure you have CMake installed.

        mkdir build
        cd build
        cmake ..
        make

The Makefile contains also additionnal rules:
        - clean: remove all the content generated by the rule all.
        - check: launch the testsuite.

.SH SYNOPSIS
.B ./42sh
[options]
[command_string | file]

.SH DESCRIPTION
.B 42sh
is a sh-compatible command language interpeter that executes command read from standard input or specified files.
.SH OPTIONS
.TP
.BR \-c \ <command>
If  the -c option is present, then commands are read from the first non-option argument command_string. Otherwise, 42sh will be opened in interactive mode.
.TP
.BR [ \- \+]O \ [shopt_options]
The option is handled by the feature will be available in version \'0.8\'.
.TP
.BR \-\-norc
This option deactivates the ressource reader.
.TP
.BR \-\-ast\-print
This option activates the AST printer. The output file is name \'ast.dot\'.
.TP
.BR \-\-version
This options prints the current 42sh version on the standard output and exits

.SH DEFINITIONS
Words can be set as keyword with a specific value inside the shell. This can be done entering as a command:
.TP
.BR keyword=value
.TP
To acces later to this value later, you will need to specify the keyword with the '$' in front of the keyword as follows:
.TP
.BR $keyword
.TP
Keywords can be re-assigned to will with the previous process.

.SH RESERVED WORDS
Reserved words are words that have a special meaning to the shell.  The  follow‐
ing  words are recognized as reserved and should not be assigned to ensure good functionment of the shell:

!  case   coproc  do done elif else esac fi for function if in select then until
while { } time [[ ]]

.SH SHELL GRAMMAR
.SS Simple commands
A simple command is a sequence of variable assigments, commands and their arguments separeted by a white space. Every simple command has an exit status which is its return value.

.SS Pipelines
A pipeline is a sequence of one or more commands separated by the operator '|'. The specificity of a pipeline lays in the usage of the standard output of the the command at the left of '|' as the standard input of the command at the right of the operator.
Moreover, commands are executed simulteanously.

.SS Lists
A list is a sequence of one or mroe pipelines separated by the operators:
.TPnoti
.BR ;
This operator specifies that commands will be executed one by one from the left to the right independantly of their exit status.
.TP
.BR &
This operator currently works as a semicolon (;)
.TP
.BR &&
This operator is the logical operator AND. If the exit status of the command at the left of the operator is 0, then the command at the right of the operator is executed and the exit status will be the one of the right command. Otherwise, the right command is not executed and the exit status is the one of the left command.
.TP
.BR ||
This operator is the logical operator OR. If the exit status of the command at the left of the operator is not 0, then the command at the right of the operator is executed and the exit status will be the one of the right command. Otherwise, the right command is not executed and the exit status is the one of the left command.

.SS Compound command
.TP
.BR list
A list is executed in the 42sh environnement. Variables assigments and builtin commands modification do not persist after the command completes. See list.
.TP
.BR list;
This is known as a group and is composed by lists. Commands persists between list but do not persist after the last command complete.

.TP
.BR ((expression))
Arithmetic expressions are not handled yet.

.TP
.BR test (expression)
Testing expression give the exit status of the expressions inside depending of the operators used, these are:

(expression): returns the value of the expression

! expression: returns true is expression is false.

expression1 && expression2: returns true if both expressions are true.

expression 1 || expression2: returns true if at least one expression is true.

.TP
\fBfor\fR 
\fIname\fR 
[ in [ [ word ... ] ; ] ] do 
\fIlist\fR
; done

For each member of the list of words, 
\fIlist\fR
is executed and
\fIname\fR
is assigned to the value of the current word.
.TP
\fBcase\fR
\fIword\fR
in [ [(] 
\fIpattern\fR
[ | 
\fIpattern\fR
] ... ) 
\fIlist\fR
;; ] ... esac

A case command try first to expand word and then try to match each pattern with. Only the 
\fIlist\fR
of the matching pattern will be executed.
.TP
\fBif\fR
\fIlist\fR;
then
\fIlist\fR; 
[ elif
\fIlist\fR;
then
\fIlist\fR; 
] ... [ else
\fIlist\fR;
] fi

The if
\fIlist\fR
is executed. If the exit status is 0, then the matching
\fIlist\fR
is executed. Otherwise, each
\fIlist\fR
are tested until one exit 0 or the last one exit.
.TP
\fBwhile\fR
\fIlist1\fR;
do
\fIlist2\fR;
done

The
\fIlist1\fR
is constanstly executed until its exit status is not 0.
For each successful (exit status 0) execution, the
\fIlist2\fR
is executed.

.TP
\fBuntil\fR
\fIlist1\fR;
do
\fIlist2\fR;
done

Similar to while, except that the execution is done until
\fIlist1\fR
exit 0

.SS Function Definitions
A function is a set of instructions that will be expanded at the call of the keyword of this function. Functions can be defined as follows:

[function]
\fIname\fR
[()] [{]
\fIcompound-command\fR
[}]

This defines the function
\fIname\fR.
Using the reserved word function make the use of the parentheses optionnal.
Use of brackets is optionnal but using one force you to use its opposite.
Defining a function with a name previously used will cause the elder function to be replaced by the new one.

.SH COMMENTS
In non-interactive shell or in interactive shell (shopt not set yet), using a '#' will cause the rest of the words in the line to be ignored by the interpretor.

.SH QUOTING
Quoting is not implemented yet.

.SH PARAMETERS
For value assignements, see DEFINITION.

.SS Positional parameters
Not handled yet.

.SS Special parameters
Not handled yet.

.SS Shell variables
The following variables are set by the shell at the beginning of its execution:
.TP
.BR PS1
The value of this parameter is expanded and used as the prompt for the primary prompt string. Its default value is "[42sh@pc]$ ".
.TP
.BR PS2
This parameter is used instead of the PS1 in the secondary prompting. Its default value is "> ".

.SH EXPANSION
If a word as a special meaning, before the execution of the instructions, the shell will go throught all the words and replace the ones with a special meaning by their real value. 
The only type of expansion handled until now is the variables expansion.

.SH REDIRECTION
Before the execution of a command, its input and outputs may be redirected using dedicated notation. The differents types of redirections are:

.TP
.BR Redirecting\ input
This kind of redirection cause the file designed by
\fIword\fR
to be used as input (or to be opened for reading for 
\fIn\fR
if precised. Format is:

        [\fIn\fR]<\fIword\fR

.TP
.BR Redirecting\ output
This kind of redirection cause the ouput (or the file descriptor 
\fIn\fR
if precised) to be redirected in the file designed by
\fIword\fR.
If the file already exists, its content would be overwritten, otherwise, the file will be created. The format is:

        [\fIn\fR]>\fIword\fR
.TP
.BR Appending\ redirected\ output
This kind of redirection cause the output (or the file descriptor 
\fIn\fR
if precised) to be redirected into the file designed by
\fIword\fR.
If the file already exists, the output would be append to the end of the file. Otherwise, the file would be created. The format is:

        [\fIn\fR]>>\fIword\fR

.TP
.BR Redirecting\ standard\ output\ and\ standard\ error
This kind of redirection cause the output and the error output to be redirected to the file designed by
\fIword\fR
If the file already exists, its content would be overwritten. Otherwise, the file would be created. The format is:

        >&\fIword\fR

.TP
.BR Here\ documents
This kind of redirection indicates the shell to read the input from the current source (standard input or file descriptor
\fIn\fR 
if specified) until a line online composed by
\fIword\fR
is encountered. The format is:

        [\fIn\fR]<<[\-]\fIword\fR

If a '-' is used, the shell will not considered the firsts tabulations of each line.

.TP
.BR Opening\ file\ descriptors\ for\ reading\ and\ writting
This kind of redirection indicates the shell to open for reading and writing the file designed by
\fIword\fR
in the standard input (or the file descriptor
\fIn\fR
if specified). The format is:

        [\fIn\fR]<>\fIword\fR

.SH ALIASES
Aliases allow to assign a special command to a keyword. If this keyword is called as a command (first argument of the string), it will be replace by its aliased value before being executed.
Be aware that all variables/commands even the vitals ones for the 42sh can be aliased, leading to an undefined behavior.

To set aliases, please refer to the builtins alias/unalias.

.SH READLINE
The promting of the shell is using readline and its library. This allows the users to have an history of its commands.

.SH SHELL BUILTIN COMMANDS
Builtins command are intern commands of the 42sh. They are not forked and executed inside the shell.
.TP
.BR .\ filename\ [arguments]
.TP
.BR source\ filename\ [arguments]
Read and execute commands from
\fIfilename\fR
in the current shell environment and return the exit status of the last command executed from 
\fIfilename\fR.
If filename does not contain a slash, filenames in PATH are used to find the directory containing filename. The file searched for in PATH need not be executable. If the sourcepath option to the shopt builtin command is turned off, the PATH is not searched. If any arguments are supplied, they become the positional parameters when 
\fIfilename\fR
is executed. Otherwise the positional parameters are unchanged.

.TP
.BR alias\ [\-p]\ [\fIname\fR[=\fIvalue\fR]\ ...]
Alias without args or with -p will print the list of aliases.
Alias with only \fIname\fR
specified will look for an existating alias named as precised and print it if found.
Alias with \fIname\fR
and \fIvalue\fR
will create a new alias.

.TP
.BR break\ [\fIn\fR]
Break will exit within a for, while or until. If \fIn\fR
is specified, it will exit on \fIn\fR
levels.

.TP
.BR cd\ [\fIdir\fR]
Change the current directory to the specified \fIdir\fR.
If no \fIdir\fR
is specified, it will change the current directory to HOME.
If \fIdir\fR
is '\-' it will change the directory to OLD_PWD.

.TP
.BR continue\ [\fIn\fR]
Continue will force a for, while or until to iterate on the next step. If \fIn\fR
is specified, it will continue on \fIn\fR
levels.

.TP
.BR echo\ [\-neE]\ [\fIarg\fR\ ...]
Print on the standard output (or its current file descriptor) the \fIargs\fR
followed by a newline.
If the \-n option is specified, no newline will be printed at the end of \fIargs\fR
by echo.
If the \-E option is specified (which is the default behavior), no escaped character will be interpreted in \fIargs\fR.
If the \-e option is specified, escaped characters will be interpreted.

.TP
.BR exit\ [\fIn\fR]
Force the shell to exit with a status of \fIn\fR.
If \fIn\fR is not specified, it will exit with the exit status of the last command executed.

.TP
.BR export\ [\-fn]\ [\fIname\fR[=\fIword\fR]]\ ...
.BR export\ \-p
The specified \fname\fR are declared as variables and set for export in the environment. If no \fIname\fR
is given or the \-p option is specified, a list of exported vriables will be printed.
Otherwise, the value will be attributed, with a \fIvalue\fR or not.

.TP
.BR history\ [n]
.TP
.BR history\ \-c
.TP
.BR history\ \-r\ [filename]
Without options, it will print the history.
With an argument \fIn\fR,
it will print the last \fIn\fR
lines of the history.
The \-c option cleans the history.
The \-r option reads the content of filename and append it to the history.

.TP
.BR unalias\ [\-a]\ [\fIname\fR\ ...]
Remove \fIname\fR
if specified.
If the \-a option is specified, all alias will be removed.

.SH SUBSHELL
Prompting a command line with the format $(\fIcommand\fR)
inside will cause the command to be executed in a depth plus one level of shell.

.SH SEE ALSO
bash(1)
readline(3)

.SH FILES
/build/42sh

.SH AUTHORS
Arthur BUSUTTIL     (arthur.busuttil@epita.fr)

Louis HOLLEVILLE    (louis.holleville@epita.fr)

Sabrina MENG        (sabrina.meng@epita.fr)

Thomas LUPIN        (thomas.lupin@epita.fr)

.SH BUG REPORT
If you find a bug in 42sh, please report with addidionnals information such as environnement, compiler used, command use, date, version and a short description to:
        louis.holleville@epita.fr
 | wc -l > nb
cat nb
rm nb
You are not guaranted that someone answers someday.

.SH BUGS
There are many bugs but it is up to you to find them.
